import numpy as np                                   # Бібліотека для роботи з масивами

# Таблиці для виконання операцій DES                 # Визначення основних таблиць алгоритму DES
# Початкова перестановка (IP)                        # Таблиця початкової перестановки вхідного блоку
IP = [58, 50, 42, 34, 26, 18, 10, 2,                # Перші 8 значень першого рядка матриці IP
      60, 52, 44, 36, 28, 20, 12, 4,                # Другі 8 значень першого рядка матриці IP
      62, 54, 46, 38, 30, 22, 14, 6,                # Треті 8 значень першого рядка матриці IP
      64, 56, 48, 40, 32, 24, 16, 8,                # Четверті 8 значень першого рядка матриці IP
      57, 49, 41, 33, 25, 17, 9, 1,                 # Перші 8 значень другого рядка матриці IP
      59, 51, 43, 35, 27, 19, 11, 3,                # Другі 8 значень другого рядка матриці IP
      61, 53, 45, 37, 29, 21, 13, 5,                # Треті 8 значень другого рядка матриці IP
      63, 55, 47, 39, 31, 23, 15, 7]                # Четверті 8 значень другого рядка матриці IP

# Кінцева перестановка (IP^-1)                      # Таблиця кінцевої перестановки (обернена до IP)
IP_INV = [40, 8, 48, 16, 56, 24, 64, 32,            # Перший рядок матриці оберненої перестановки
          39, 7, 47, 15, 55, 23, 63, 31,            # Другий рядок матриці оберненої перестановки
          38, 6, 46, 14, 54, 22, 62, 30,            # Третій рядок матриці оберненої перестановки
          37, 5, 45, 13, 53, 21, 61, 29,            # Четвертий рядок матриці оберненої перестановки
          36, 4, 44, 12, 52, 20, 60, 28,            # П'ятий рядок матриці оберненої перестановки
          35, 3, 43, 11, 51, 19, 59, 27,            # Шостий рядок матриці оберненої перестановки
          34, 2, 42, 10, 50, 18, 58, 26,            # Сьомий рядок матриці оберненої перестановки
          33, 1, 41, 9, 49, 17, 57, 25]             # Восьмий рядок матриці оберненої перестановки

# Розширення E                                       # Таблиця розширення 32-бітного блоку до 48 бітів
E = [32, 1, 2, 3, 4, 5,                             # Перший рядок таблиці розширення E
     4, 5, 6, 7, 8, 9,                              # Другий рядок таблиці розширення E
     8, 9, 10, 11, 12, 13,                          # Третій рядок таблиці розширення E
     12, 13, 14, 15, 16, 17,                        # Четвертий рядок таблиці розширення E
     16, 17, 18, 19, 20, 21,                        # П'ятий рядок таблиці розширення E
     20, 21, 22, 23, 24, 25,                        # Шостий рядок таблиці розширення E
     24, 25, 26, 27, 28, 29,                        # Сьомий рядок таблиці розширення E
     28, 29, 30, 31, 32, 1]                         # Восьмий рядок таблиці розширення E

# Перестановка P                                     # Таблиця перестановки P в функції Фейстеля
P = [16, 7, 20, 21, 29, 12, 28, 17,                 # Перший рядок таблиці перестановки P
     1, 15, 23, 26, 5, 18, 31, 10,                  # Другий рядок таблиці перестановки P
     2, 8, 24, 14, 32, 27, 3, 9,                    # Третій рядок таблиці перестановки P
     19, 13, 30, 6, 22, 11, 4, 25]                  # Четвертий рядок таблиці перестановки P

# S-блоки                                            # Блоки заміни (S-boxes) для перетворення даних
S_BOXES = [                                          # Масив з 8 S-блоків
    # S1                                             # Перший S-блок (S1)
    [                                                # Матриця 4x16 для S1
        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],  # Перший рядок S1
        [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],  # Другий рядок S1
        [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],  # Третій рядок S1
        [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]   # Четвертий рядок S1
    ],
    # S2                                             # Другий S-блок (S2)
    [                                                # Матриця 4x16 для S2
        [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],  # Перший рядок S2
        [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],  # Другий рядок S2
        [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],  # Третій рядок S2
        [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]   # Четвертий рядок S2
    ],
    # S3                                             # Третій S-блок (S3)
    [                                                # Матриця 4x16 для S3
        [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],  # Перший рядок S3
        [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],  # Другий рядок S3
        [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],  # Третій рядок S3
        [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]   # Четвертий рядок S3
    ],
    # S4                                             # Четвертий S-блок (S4)
    [                                                # Матриця 4x16 для S4
        [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],  # Перший рядок S4
        [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],  # Другий рядок S4
        [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],  # Третій рядок S4
        [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]   # Четвертий рядок S4
    ],
    # S5                                             # П'ятий S-блок (S5)
    [                                                # Матриця 4x16 для S5
        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],  # Перший рядок S5
        [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],  # Другий рядок S5
        [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],  # Третій рядок S5
        [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]   # Четвертий рядок S5
    ],
    # S6                                             # Шостий S-блок (S6)
    [                                                # Матриця 4x16 для S6
        [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],  # Перший рядок S6
        [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],  # Другий рядок S6
        [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],  # Третій рядок S6
        [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]   # Четвертий рядок S6
    ],
    # S7                                             # Сьомий S-блок (S7)
    [                                                # Матриця 4x16 для S7
        [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],  # Перший рядок S7
        [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],  # Другий рядок S7
        [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],  # Третій рядок S7
        [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]   # Четвертий рядок S7
    ],
    # S8                                             # Восьмий S-блок (S8)
    [                                                # Матриця 4x16 для S8
        [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],  # Перший рядок S8
        [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],  # Другий рядок S8
        [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],  # Третій рядок S8
        [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]   # Четвертий рядок S8
    ]
]

# Таблиця для перестановки зі стисненням (перестановка PC-1)  # Таблиця PC1 для обробки початкового ключа
PC1 = [57, 49, 41, 33, 25, 17, 9,                   # Перший рядок таблиці PC1
       1, 58, 50, 42, 34, 26, 18,                   # Другий рядок таблиці PC1
       10, 2, 59, 51, 43, 35, 27,                   # Третій рядок таблиці PC1
       19, 11, 3, 60, 52, 44, 36,                   # Четвертий рядок таблиці PC1
       63, 55, 47, 39, 31, 23, 15,                  # П'ятий рядок таблиці PC1
       7, 62, 54, 46, 38, 30, 22,                   # Шостий рядок таблиці PC1
       14, 6, 61, 53, 45, 37, 29,                   # Сьомий рядок таблиці PC1
       21, 13, 5, 28, 20, 12, 4]                    # Восьмий рядок таблиці PC1

# Таблиця для утворення ключів для кожного раунда (перестановка PC-2)  # Таблиця PC2 для генерації підключів
PC2 = [14, 17, 11, 24, 1, 5, 3, 28,                 # Перший рядок таблиці PC2
       15, 6, 21, 10, 23, 19, 12, 4,                # Другий рядок таблиці PC2
       26, 8, 16, 7, 27, 20, 13, 2,                 # Третій рядок таблиці PC2
       41, 52, 31, 37, 47, 55, 30, 40,              # Четвертий рядок таблиці PC2
       51, 45, 33, 48, 44, 49, 39, 56,              # П'ятий рядок таблиці PC2
       34, 53, 46, 42, 50, 36, 29, 32]              # Шостий рядок таблиці PC2

# Кількість зсувів для кожного раунду                # Кількість бітів для зсуву в кожному раунді
SHIFT_LEFT = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]  # Масив зсувів для 16 раундів

def string_to_bit_array(text):                      # Функція перетворення тексту в бітовий масив
    """Перетворює текст у масив бітів (в бінарному форматі)"""  # Опис функції
    # Перетворюємо текст у байти з кодуванням utf-8  # Конвертація тексту в байти
    text_bytes = text.encode('utf-8')                # Кодування тексту в UTF-8
    array = []                                       # Створення порожнього масиву для бітів
    for byte in text_bytes:                          # Цикл по кожному байту
        # Перетворення байту у 8-бітовий код         # Конвертація байту в двійкове представлення
        bin_val = bin(byte)[2:].zfill(8)             # Формування 8-бітового представлення
        # Додавання кожного біту у масив             # Додавання кожного біту до масиву
        for bit in bin_val:                          # Цикл по кожному біту
            array.append(int(bit))                   # Додавання біту до масиву як ціле число
    return array                                     # Повернення масиву бітів

def bit_array_to_string(array):                     # Функція перетворення бітового масиву в текст
    """Перетворює масив бітів у текст"""             # Опис функції
    # Збираємо байти з бітів                         # Об'єднання бітів у байти
    bytes_array = bytearray()                        # Створення порожнього байтового масиву
    for i in range(0, len(array), 8):                # Цикл з кроком 8 (для кожного байту)
        # Беремо 8 бітів і перетворюємо їх у байт    # Обробка кожного байту
        byte = array[i:i+8]                          # Вибір 8 бітів для одного байту
        if len(byte) == 8:  # Перевіряємо, що маємо повний байт  # Перевірка повноти байту
            byte_val = int(''.join([str(bit) for bit in byte]), 2)  # Конвертація бітів у число
            bytes_array.append(byte_val)             # Додавання байту до байтового масиву

    # Декодуємо байти назад у текст з utf-8          # Конвертація байтів назад у текст
    try:                                             # Спроба декодування
        return bytes_array.decode('utf-8')           # Декодування байтів у текст з UTF-8
    except UnicodeDecodeError:                       # Обробка помилки декодування
        # Якщо виникає помилка декодування, повертаємо доступну частину або порожній рядок  # Часткове відновлення тексту
        for i in range(len(bytes_array), 0, -1):     # Цикл від кінця до початку
            try:                                     # Спроба декодування частини байтів
                return bytes_array[:i].decode('utf-8')  # Декодування частини байтів
            except UnicodeDecodeError:               # Якщо виникла помилка
                continue                             # Продовження циклу
        return ""                                    # Повернення порожнього рядка у разі невдачі

def permute(block, table):                          # Функція перестановки бітів за таблицею
    """Виконує перестановку бітів згідно з таблицею"""  # Опис функції
    return [block[x-1] for x in table]               # Повернення бітів згідно з таблицею перестановки

def split(block):                                   # Функція розділення блоку на дві частини
    """Розділяє блок на дві рівні частини"""         # Опис функції
    return block[:len(block)//2], block[len(block)//2:]  # Повернення лівої та правої половин

def xor(a, b):                                      # Функція виконання операції XOR
    """Виконує операцію XOR (побітове додавання за модулем 2) над двома масивами бітів"""  # Опис функції
    return [a[i] ^ b[i] for i in range(len(a))]     # Повернення результату XOR для кожної пари бітів

def shift_left(block, count):                       # Функція циклічного зсуву вліво
    """Циклічний зсув бітів вліво на вказану кількість позицій"""  # Опис функції
    return block[count:] + block[:count]             # Повернення зсунутого блоку

def generate_subkeys(key):                          # Функція генерації підключів
    """Генерує 16 підключів для 16 раундів алгоритму DES"""  # Опис функції
    # Конвертація ключа у 64-бітний масив            # Перетворення ключа в бітовий масив
    key_bit_array = string_to_bit_array(key)         # Виклик функції перетворення рядка в біти

    # Якщо ключ коротший за 8 байт (64 біти), доповнюємо його нулями  # Обробка ключа недостатньої довжини
    if len(key_bit_array) < 64:                      # Перевірка довжини ключа
        key_bit_array = key_bit_array + [0] * (64 - len(key_bit_array))  # Доповнення ключа нулями
    # Якщо ключ довший за 8 байт, обрізаємо його     # Обробка ключа надмірної довжини
    elif len(key_bit_array) > 64:                    # Перевірка довжини ключа
        key_bit_array = key_bit_array[:64]           # Обрізання ключа до 64 бітів

    # Перестановка PC1 (стискає ключ з 64 до 56 бітів)  # Виконання перестановки PC1
    key_56 = permute(key_bit_array, PC1)             # Перестановка ключа за таблицею PC1

    # Розділення на ліву і праву частини             # Поділ ключа на дві частини
    left, right = split(key_56)                      # Розділення 56-бітного ключа

    # Генерація 16 підключів                         # Початок генерації підключів
    subkeys = []                                     # Створення порожнього масиву для підключів
    for i in range(16):                              # Цикл для 16 раундів
        # Зсув вліво                                 # Виконання зсуву для обох частин
        left = shift_left(left, SHIFT_LEFT[i])       # Зсув лівої частини
        right = shift_left(right, SHIFT_LEFT[i])     # Зсув правої частини

        # Об'єднання частин та перестановка PC2 (від 56 до 48 бітів)  # Формування підключа
        combined = left + right                       # Об'єднання лівої та правої частин
        subkey = permute(combined, PC2)              # Перестановка за таблицею PC2

        subkeys.append(subkey)                       # Додавання підключа до масиву

    return subkeys                                   # Повернення масиву підключів
def f_function(right_block, subkey):                                 # Функція f, яка використовується в кожному раунді DES
    """Функція f в алгоритмі DES"""                                  # Документація функції
    # Розширення 32-бітного блоку до 48 бітів                        # Опис наступної операції
    expanded = permute(right_block, E)                               # Розширення блоку за допомогою таблиці E

    # XOR розширеного блоку з підключем                              # Опис наступної операції
    xor_result = xor(expanded, subkey)                               # Побітовий XOR з підключем раунду

    # Застосування S-блоків (із 48 бітів у 32 біти)                  # Опис наступної операції
    s_box_output = []                                                # Ініціалізація списку для результату S-блоків
    for i in range(8):                                               # Цикл для обробки всіх 8 S-блоків
        # Беремо 6 бітів для поточного S-блоку                       # Опис наступної операції
        current_6_bits = xor_result[i*6:(i+1)*6]                     # Вибір 6 бітів для поточного S-блоку

        # Обчислюємо рядок і стовпчик для S-блоку                    # Опис наступної операції
        row = int(str(current_6_bits[0]) + str(current_6_bits[5]), 2) # Обчислення номера рядка (біти 1 і 6)
        col = int(''.join([str(bit) for bit in current_6_bits[1:5]]), 2) # Обчислення номера стовпця (біти 2-5)

        # Отримуємо значення з S-блоку                               # Опис наступної операції
        val = S_BOXES[i][row][col]                                   # Отримання значення з відповідного S-блоку

        # Перетворюємо значення у 4-бітовий формат                   # Опис наступної операції
        bin_val = bin(val)[2:].zfill(4)                              # Конвертація числа в 4-бітове двійкове представлення
        for bit in bin_val:                                          # Цикл для додавання кожного біту до результату
            s_box_output.append(int(bit))                            # Додавання біту до вихідного списку

    # Перестановка P                                                 # Опис наступної операції
    return permute(s_box_output, P)                                  # Кінцева перестановка і повернення результату

def des_encrypt_block(block, subkeys):                               # Функція шифрування одного блоку DES
    """Шифрує один 64-бітний блок за допомогою алгоритму DES"""      # Документація функції
    # Початкова перестановка                                         # Опис наступної операції
    block = permute(block, IP)                                       # Застосування початкової перестановки IP

    # Розділення на ліву і праву частини                             # Опис наступної операції
    left, right = split(block)                                       # Розділення 64-бітного блоку на дві 32-бітні частини

    # 16 раундів шифрування                                          # Опис наступних операцій
    for i in range(16):                                              # Цикл для 16 раундів шифрування
        # Зберігаємо попередню праву частину                         # Опис наступної операції
        prev_right = right                                           # Збереження поточної правої частини

        # Функція f                                                  # Опис наступної операції
        f_result = f_function(right, subkeys[i])                     # Застосування функції f до правої частини

        # XOR лівої частини з результатом функції f                   # Опис наступної операції
        right = xor(left, f_result)                                  # Обчислення нової правої частини

        # Нова ліва частина - попередня права частина                # Опис наступної операції
        left = prev_right                                            # Оновлення лівої частини

        # Для демонстрації виводимо результати першого раунду        # Опис наступного умовного блоку
        if i == 0:                                                   # Перевірка, чи це перший раунд
            print(f"Після 1-го раунду:")                             # Виведення заголовка
            print(f"Ліва частина: {''.join([str(bit) for bit in left])}")  # Виведення лівої частини
            print(f"Права частина: {''.join([str(bit) for bit in right])}")  # Виведення правої частини

    # Фінальне об'єднання (у зворотному порядку: права + ліва)       # Опис наступної операції
    combined = right + left                                          # Об'єднання блоків у зворотному порядку

    # Кінцева перестановка                                           # Опис наступної операції
    result = permute(combined, IP_INV)                               # Застосування кінцевої перестановки IP^-1

    return result                                                    # Повернення зашифрованого блоку

def des_encrypt(text, key):                                          # Функція шифрування тексту алгоритмом DES
    """Шифрує текст за допомогою алгоритму DES у режимі ECB"""       # Документація функції
    # Генеруємо підключі                                             # Опис наступної операції
    subkeys = generate_subkeys(key)                                  # Генерація 16 підключів з основного ключа

    # Конвертація тексту в бітовий масив                             # Опис наступної операції
    text_bit_array = string_to_bit_array(text)                       # Перетворення тексту в масив бітів

    # Доповнення масиву до кратності 64                              # Опис наступного блоку
    if len(text_bit_array) % 64 != 0:                                # Перевірка необхідності доповнення
        padding_length = 64 - (len(text_bit_array) % 64)             # Розрахунок довжини необхідного доповнення
        text_bit_array = text_bit_array + [0] * padding_length       # Додавання нульових бітів для вирівнювання

    result = []                                                      # Ініціалізація списку для результату

    # Обробка тексту блоками по 64 біти                              # Опис наступного циклу
    for i in range(0, len(text_bit_array), 64):                      # Цикл по блокам тексту
        block = text_bit_array[i:i+64]                               # Вибір поточного блоку
        result.extend(des_encrypt_block(block, subkeys))             # Шифрування блоку і додавання до результату

    return result                                                    # Повернення зашифрованого тексту

def des_decrypt(cipher_bits, key):                                   # Функція дешифрування тексту
    """Дешифрує текст, зашифрований алгоритмом DES"""                # Документація функції
    # Генеруємо підключі (використовуємо їх у зворотному порядку для дешифрування)  # Опис наступного блоку
    subkeys = generate_subkeys(key)                                  # Генерація підключів
    subkeys.reverse()                                                # Інверсія порядку підключів для дешифрування

    result = []                                                      # Ініціалізація списку для результату

    # Обробка шифротексту блоками по 64 біти                         # Опис наступного циклу
    for i in range(0, len(cipher_bits), 64):                         # Цикл по блокам шифротексту
        block = cipher_bits[i:i+64]                                  # Вибір поточного блоку
        result.extend(des_encrypt_block(block, subkeys))             # Дешифрування блоку і додавання до результату

    # Видалення доповнення (якщо є)                                  # Опис наступного циклу
    while result and result[-1] == 0:                                # Цикл для видалення доповнення
        result.pop()                                                 # Видалення нульового біту

    return bit_array_to_string(result)                               # Перетворення бітів у текст і повернення

def print_bits_as_hex(bits):                                         # Функція для відображення бітів у шістнадцятковому форматі
    """Перетворює масив бітів у шістнадцятковий формат для відображення"""  # Документація функції
    hex_output = ""                                                  # Ініціалізація рядка для результату
    for i in range(0, len(bits), 4):                                 # Цикл по групам з 4 бітів (нібблам)
        if i + 4 <= len(bits):  # Перевіряємо, що маємо повний ніббл # Перевірка наявності повного ніббла
            nibble = bits[i:i+4]                                     # Вибір поточного ніббла
            hex_digit = hex(int(''.join([str(bit) for bit in nibble]), 2))[2:]  # Конвертація в шістнадцятковий символ
            hex_output += hex_digit                                  # Додавання символу до результату
    return hex_output                                                # Повернення шістнадцяткового представлення

# Демонстрація роботи алгоритму                                      # Опис наступної функції
def demonstrate_des():                                               # Функція для демонстрації роботи DES
    # Використовуємо ваші дані                                       # Опис наступного блоку
    plaintext = "Диннік Михайло Андрійович, група 12-341"            # Встановлення тексту для шифрування
    # Ключ (рекомендується 8 символів для 64-бітного ключа)          # Опис наступного рядка
    key = "secretky"                                                 # Встановлення ключа шифрування

    print(f"Текст для шифрування: {plaintext}")                      # Виведення початкового тексту
    print(f"Ключ: {key}")                                            # Виведення ключа

    # Шифрування                                                     # Опис наступного блоку
    print("\nШифрування:")                                           # Виведення заголовка
    encrypted_bits = des_encrypt(plaintext, key)                     # Шифрування тексту
    print(f"Зашифрований текст (HEX): {print_bits_as_hex(encrypted_bits)}")  # Виведення зашифрованого тексту

    # Дешифрування                                                   # Опис наступного блоку
    print("\nДешифрування:")                                         # Виведення заголовка
    decrypted_text = des_decrypt(encrypted_bits, key)                # Дешифрування тексту
    print(f"Розшифрований текст: {decrypted_text}")                  # Виведення розшифрованого тексту

    # Детальний аналіз першого раунду                                # Опис наступного блоку
    print("\nДетальний аналіз першого раунду:")                      # Виведення заголовка
    # Конвертація тексту та ключа у бітові масиви                    # Опис наступного рядка
    text_bits = string_to_bit_array(plaintext)                       # Перетворення тексту в масив бітів
    # Беремо перші 64 біти для аналізу                               # Опис наступного умовного блоку
    if len(text_bits) < 64:                                          # Перевірка довжини бітового масиву
        text_bits = text_bits + [0] * (64 - len(text_bits))          # Доповнення до 64 бітів
    block_bits = text_bits[:64]                                      # Вибір перших 64 бітів

    # Генерація підключів                                            # Опис наступного рядка
    subkeys = generate_subkeys(key)                                  # Генерація підключів з ключа

    # Початкова перестановка                                         # Опис наступного блоку
    initial_permutation = permute(block_bits, IP)                    # Застосування початкової перестановки
    print(f"Після початкової перестановки (IP): {print_bits_as_hex(initial_permutation)}")  # Виведення результату

    # Розділення на ліву і праву частини                             # Опис наступного блоку
    left, right = split(initial_permutation)                         # Розділення на ліву і праву частини
    print(f"Ліва частина (L0): {print_bits_as_hex(left)}")          # Виведення лівої частини
    print(f"Права частина (R0): {print_bits_as_hex(right)}")        # Виведення правої частини

    # Розширення правої частини                                      # Опис наступного блоку
    expanded_right = permute(right, E)                               # Розширення правої частини
    print(f"Розширена права частина (E(R0)): {print_bits_as_hex(expanded_right)}")  # Виведення результату

    # XOR з підключем першого раунду                                 # Опис наступного блоку
    xor_result = xor(expanded_right, subkeys[0])                     # Операція XOR з першим підключем
    print(f"Результат XOR з підключем K1: {print_bits_as_hex(xor_result)}")  # Виведення результату

    # Застосування S-блоків                                          # Опис наступного блоку
    s_box_output = []                                                # Ініціалізація списку для результату
    for i in range(8):                                               # Цикл для всіх 8 S-блоків
        current_6_bits = xor_result[i*6:(i+1)*6]                     # Вибір 6 бітів для поточного S-блоку
        row = int(str(current_6_bits[0]) + str(current_6_bits[5]), 2) # Обчислення номера рядка
        col = int(''.join([str(bit) for bit in current_6_bits[1:5]]), 2) # Обчислення номера стовпця
        val = S_BOXES[i][row][col]                                   # Отримання значення з S-блоку
        bin_val = bin(val)[2:].zfill(4)                              # Конвертація в 4-бітове представлення
        for bit in bin_val:                                          # Цикл для додавання бітів
            s_box_output.append(int(bit))                            # Додавання біту до результату
    print(f"Вихід S-блоків: {print_bits_as_hex(s_box_output)}")     # Виведення результату S-блоків

    # Перестановка P                                                 # Опис наступного блоку
    p_result = permute(s_box_output, P)                              # Застосування перестановки P
    print(f"Результат перестановки P: {print_bits_as_hex(p_result)}")  # Виведення результату

    # Нова права частина                                             # Опис наступного блоку
    new_right = xor(left, p_result)                                  # Обчислення нової правої частини
    print(f"Нова права частина (R1): {print_bits_as_hex(new_right)}")  # Виведення нової правої частини

    # Нова ліва частина                                              # Опис наступного блоку
    new_left = right                                                 # Встановлення нової лівої частини
    print(f"Нова ліва частина (L1): {print_bits_as_hex(new_left)}")  # Виведення нової лівої частини

# Запуск демонстрації                                                # Опис наступного блоку
if __name__ == "__main__":                                           # Перевірка, чи файл запущено напряму
    demonstrate_des()                                                # Виклик функції демонстрації